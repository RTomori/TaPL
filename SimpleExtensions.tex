%%% Local Variables:
%%% mode: japanese-laTeX
%%% TeX-engine: xetex
%%% End;
\documentclass[9pt]{beamer}
 \usepackage{zxjatype}
 \usepackage{xltxtra}
 \usepackage[ipa]{zxjafont}
\usepackage{amssymb, amsmath,amsfonts}
\usepackage{mathtools}
\usepackage{bussproofs}
\usepackage{mathcomp}
\usepackage{tcolorbox}
\usepackage{mathrsfs}
\tcbuselibrary{raster,skins}
\usepackage{varwidth}
\usepackage{listings}
\usepackage{manfnt}
\usepackage{array}
\usepackage{bcprules}
\usetheme{metropolis}

% 色定\textmd{}義
\definecolor{mstruct}{RGB}{68, 174, 234} 
% \definecolor{malert}{RGB}{223, 153, 155}
\definecolor{malert}{RGB}{255, 76, 0}
\definecolor{mex}{RGB}{57, 149, 82}
% 見出しカラー
% block title color
% alert color
% 箇条書き
\useinnertheme{circles}
% フッダー
\setbeamertemplate{footline}[frame number]
%無を出力するコマンド
\newtcolorbox{tblock}[1]{
	enhanced, skin=enhancedlast jigsaw,
	attach boxed title to top left={xshift=-4mm,yshift=-0.5mm},
	colbacktitle=mstruct, colframe=mstruct\textmd{},
	interior style={top color=mstruct!10!white, bottom color=white},
	boxed title style={empty,arc=0pt,outer arc=0pt,boxrule=0pt},
	underlay boxed title={
		\fill[mstruct] (title.north west) -- (title.north east)
		-- +(\tcboxedtitleheight-1mm,-\tcboxedtitleheight+1mm)
		-- ([xshift=4mm,yshift=0.5mm]frame.north east) -- +(0mm,-1mm)
		-- (title.south west) -- cycle;
		\fill[mstruct!45!white!50!black] ([yshift=-0.5mm]frame.north west)
		-- +(-0.4,0) -- +(0,-0.3) -- cycle;
		\fill[mstruct!45!white!50!black] ([yshift=-0.5mm]frame.north east)
		-- +(0,-0.3) -- +(0.4,0) -- cycle; 
	},
	title=#1
}
% Definition Box
\newtcolorbox{dblock}[1]{enhanced, skin=enhancedlast jigsaw,
	attach boxed title to top left={xshift=-4mm,yshift=-0.5mm},
	colbacktitle=malert, colframe=malert,
	interior style={top color=malert!10!white, bottom color=white},
	boxed title style={empty,arc=0pt,outer arc=0pt,boxrule=0pt},
	underlay boxed title={
		\fill[malert] (title.north west) -- (title.north east)
		-- +(\tcboxedtitleheight-1mm,-\tcboxedtitleheight+1mm)
		-- ([xshift=4mm,yshift=0.5mm]frame.north east) -- +(0mm,-1mm)
		-- (title.south west) -- cycle;
		\fill[malert!45!white!50!black] ([yshift=-0.5mm]frame.north west)
		-- +(-0.4,0) -- +(0,-0.3) -- cycle;
		\fill[malert!45!white!50!black] ([yshift=-0.5mm]frame.north east)
		-- +(0,-0.3) -- +(0.4,0) -- cycle; 
	},
	title=#1
}
% subbox
\newtcolorbox{subbox}[1]{
	empty,
	coltitle=mstruct, fonttitle=\bfseries,
	borderline horizontal={0.5mm}{0pt}{mstruct},
	title=#1
	titlerule style={
		mstruct,
		arrows={Hooks[arc=270]-Hooks[arc=270]}
	}
}

\newcommand{\dnote}[1]{%
    \noindent % I guess this is intended...
    \begin{tabular}{@{}m{0.13\textwidth}@{}m{0.87\textwidth}@{}}%
        \huge\textdbend &#1%
    \end{tabular}%
    \par % ... and this too.
}

\everymath{\displaystyle}
\title{Types and Programming Languages\\ Chapter 11-14}
\author{Rei Tomori}
\begin{document}
\maketitle
\begin{frame}{概要}
	今回は以下の内容を扱う: \begin{enumerate}
        \item \S 11. 単純な拡張(\S11.4-)
        \item \S 12. 正規化
        \item \S 13. 参照
        \item \S14. 例外
    \end{enumerate}
\end{frame}
\section{\S11. 単純な拡張}
\subsection{\S11.1 基本型}
\begin{frame}{基本型}
    \begin{enumerate}
    \item プログラミング言語には基本型\footnote{基底型}.i.e.構造を持たない単純な値の集合とその上のプリミティブな演算がある．\begin{itemize}
    \item 今後は$\mathtt{Nat, Bool}$に加え，$\mathtt{String, Float}$型を用いる．
    \end{itemize}
    \item (その上の演算を捨象した)一般的な基本型を扱いたいことがある．そのためには，言語が"非解釈の"基本型の集合$\mathscr{A}$\footnote{原子型，つまり型システムにおいては内部システムを持たない型の略}を備えているとする．\begin{itemize}
    \item これを表わすためには，型の構文規則を変更してメタ変数$\mathtt{A}$($\mathscr{A}$の要素を表わす)を加える．
    \item 以降，基本型の名前として$\mathtt{A, B, C}$を用いる．
    \end{itemize}
    \item 非解釈な型を導入することで，基本型の要素上を特定することなく，その上で走る変数を束縛できる．\begin{itemize}
    \item $\mathtt{\lambda x:A. x}$は$\mathtt{x:A}$が何であれ，$\mathtt{x}$を$\mathtt{x}$自身に写す恒等関数である．
    \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}{\S11.2. $\mathtt{Unit}$型}
    要素を 1 つしか持たない型である$\mathtt{Unit}$型を導入する．この型は次のように解釈される:\begin{itemize}
    \item 唯一の要素は項定数$\mathtt{unit}$($\mathtt{u}$，しばしば()で表わされる)で，任意の$\mathtt{Unit}$型の項は一意的に$\mathtt{unit}$に評価される．
    \end{itemize}
    $\mathtt{Unit}$型は主に副作用を持つ言語で応用される\footnote{純粋函数型言語では，たとえば各$n\in\mathbb{N}$に対して}．たとえば，可変参照を変更する関数では，返り値ではなく副作用に興味があるため，$\mathtt{Unit}$型が返り値の型とされる．類似物として C 系言語の$\mathtt{void}$型がある．
    \end{frame}
\begin{frame}{Unit 型}
$\mathtt{Unit}$型は\footnote{Haskell でいうところの 0-tuple}，以下の構文，型付け規則および派生形式(i.e.糖衣構文)，すなわち STLC への埋め込み方で定義される．
\begin{dblock}{Def.$\mathtt{Unit}$型の定義}
	\begin{columns}
		\begin{column}{0.30\textwidth}
			新しい構文形式
			\begin{align*}
			\mathtt{\text{(項)\ }t}\Coloneq&\ldots\\
                                        &\mathtt{Unit}
			\end{align*}
        \begin{align*}
                \mathtt{\text{(項)\ }v}\Coloneq&\ldots\\
                &\mathtt{unit}
            \end{align*}
            \begin{align*}
                \mathtt{\text{(型)\ }T}\Coloneq&\ldots\\
                &\mathtt{Unit}
            \end{align*}
		\end{column}\begin{column}{0.66\textwidth}
			新しい型付け規則\begin{prooftree}
				\AxiomC{$\Gamma\vdash \mathtt{unit:Unit}$}
			\end{prooftree}
            新しい派生形式
            \begin{align*}
                \mathtt{t_{1};t_{2}}&\stackrel{\text{def}}{=}(\lambda \mathtt{x:Unit. t_{2}})\mathtt{t_{1}}\\
                    &\text{ただし}x\notin FV(\mathtt{t_{2}})
            \end{align*}
		\end{column}
	\end{columns}\end{dblock}
\end{frame}
\begin{frame}{\S11.3.派生形式: 逐次実行とワイルドカード}
副作用のある言語における文の逐次実行を形式化する．逐次実行形式は項$\mathtt{t_{1}, t_{2}}$に対し，$\mathtt{t_{1}}$を正規形まで評価し，結果を捨てた後に$\mathtt{t_{2}}$を評価する．

$(;)$の意味を直接表わす方法と，$(;)$を内部言語のある項の略記とする 2 通りの形式化が考えられる．\begin{enumerate}\item $\mathtt{t_{1};t_{2}}$を新たな構文要素とする方法．評価規則
\begin{prooftree}
\AxiomC{$\mathtt{t_{1}\rightarrow t'_{1}}$}
\RightLabel{\tiny\rm{(E-SEQ)}}
\UnaryInfC{$\mathtt{t_{1};t_{2}\rightarrow t'_{1};t_{2}}$}
\end{prooftree}
\begin{prooftree}
        \AxiomC{}
        \noLine
        \UnaryInfC{$\mathtt{v_{1};t_{2}\rightarrow t_{2}}$\ \tiny\rm{(E-SEQNEXT)}}
\end{prooftree}
および型付け規則
\begin{prooftree}
\AxiomC{$\Gamma\vdash\mathtt{t_{1}:Unit}$}
\AxiomC{$\Gamma\vdash\mathtt{t_{2}:T_{2}}$}
\RightLabel{\tiny\rm{(T-SEQ)}}
\BinaryInfC{$\Gamma\vdash\mathtt{t_{1};t_{2}:T_{2}}$}
\end{prooftree}を付け加えることで$(;)$の振る舞いを特徴付ける．
\item 内部言語の項の略記とする方法．$\mathtt{t_{1};t_{2}\stackrel{def}{=}(\lambda x:Unit. t_{2})t_{1}}$，ただし$x\mathtt{x}\notin FV(\mathtt{t_{2}})$とする．
\end{enumerate}
\end{frame}
\begin{frame}{派生形式}
はじめの形式化で定めた評価および型付け規則は，$\mathtt{Unit}$のみを型として持つ STLC の評価関係および型付け規則より従う．このことを確認しよう．
\begin{alertblock}{Thm.11.3.1[逐次実行は派生形式である]}
    $\mathtt{Unit}$型，逐次実行およびそれらの評価・型付け規則を持つ STLC を$\lambda^{E}$と書く．\footnote{外部言語の略．}また，$\mathtt{Unit}$型のみを持つ STLC を$\lambda^{I}$と書き，$e\in\lambda^{I}\to\lambda^{E}$を，$\lambda^{I}$の各項を対応する$\lambda^{E}$の項に写す詳細化関数\footnote{elaboration function}とする．つまり，$e$は$\mathtt{t_{1};t_{2}}$の各出現を，$\mathtt{(\lambda x:Unit. t_{2})t_{1}}(\mathtt{x}\notin FV(\mathtt{t_{2}}))$に置き換える．すると，$\lambda^{E}$の各項$\mathtt{t}$に対して，\begin{enumerate}
    \item $\mathtt{t\rightarrow_{E} t'}\Rightarrow e(\mathtt{t})\rightarrow_{I} e(\mathtt{t'})$．逆に$e(\mathtt{t})\rightarrow_{I}\mathtt{u}\Rightarrow\exists \mathtt{t'}.\mathtt{t'}$は$\lambda^{E}$の項$\land \mathtt{u} = e(\mathtt{t'})\land \mathtt{t\rightarrow_{E}t'}$．
    \item $\Gamma\vdash^{E}\mathtt{t:T}\Leftrightarrow \Gamma\vdash^{I}e\mathtt{(t):T}$
    \end{enumerate}
\end{alertblock}
\end{frame}
\begin{frame}{Thm.11.3.1.の証明(一部)}
    \begin{proof}
       $\mathtt{t}$の構造帰納法で示す．(2)の主張は白板で示すことにする．
        \begin{enumerate}
        \item (1)の証明．\begin{enumerate}
        \item $(\Rightarrow)$ 新たな構文要素，つまり$\mathtt{t = t_{1};t_{2}}$または$\mathtt{t = v_{1};t_{2}}$の場合を考え，$\mathtt{t\rightarrow_{E} t'}$なる$\mathtt{t'}$の存在を仮定．\begin{itemize}
        \item $\mathtt{t = v_{1};t_{2}}$．仮定より$\mathtt{t' = t_{2}}$．いま$\mathtt{x}\notin FV(\mathtt{t_{2}})$を任意に取ると，定義より$e(\mathtt{t}) = \mathtt{(\lambda x: Unit. }e\mathtt{(t_{2}))\ v_{1}}$．$\text{\rm(E-APPABS)}$から$\mathtt{t}\rightarrow_{I}\left[\mathtt{x\mapsto v_{1}}\right]e\mathtt{(t_{2})} = \mathtt{t'}$がいえ，$\mathtt{x\notin}FV(e(\mathtt{t_{2}}))$からこれは$\mathtt{v_{1}}$に等しい．
        \item $\mathtt{t = t_{1};t_{2}}$．仮定より$\mathtt{t' = t'_{1};t_{2}}\land \mathtt{t_{1}\rightarrow_{E}t'_{1}}$なる$\mathtt{t', t'_{1}}$が存在．IH より$e(\mathtt{t_{1}}) \rightarrow_{I} e(\mathtt{t'_{1}})$．$\text{\rm{(E-APP1)}}$から$e(\mathtt{t}) = e(\mathtt{t_{1}})e(\mathtt{t_{2}})\rightarrow_{I} e(\mathtt{t'_{1}})e(\mathtt{t_{2}} = e(\mathtt{t'})$．
        \end{itemize}
        \item $(\Leftarrow)$．$e(\mathtt{t})\rightarrow_{I}\mathtt{u}$を仮定する．(1)と同様に場合を分ける．\begin{itemize}
        \item $\mathtt{t = v_{1};t_{2}}$のとき．$e(\mathtt{t}) = \mathtt{(\lambda x:Unit. }e\mathtt{(t_{2}))v_{1}}$($\mathtt{x}$は fresh な変数)，$\mathtt{u} = e(\mathtt{t_{2}})$．このとき．$\mathtt{t' = t_{2}}$とすれば従う．
        \item $\mathtt{t = t_{1};t_{2}}$のとき．$\mathtt{t} = (\mathtt{\lambda x:Unit.}e (\mathtt{t_{2}}))\ e(\mathtt{t_{1}})$であり，仮定より$e(\mathtt{t_{1}})\rightarrow \mathtt{u'_{1}}$なる$\mathtt{u'_{1}}$を取ると$\mathtt{u} = (\mathtt{\lambda x:Unit.}e(\mathtt{t_{1}}))\ \mathtt{u'_{1}}$．帰納法の仮定より，$\mathtt{u'_{1}} = e(\mathtt{t'_{1}})\land \mathtt{t_{1}}\rightarrow_{E} \mathtt{t'_{1}}$なる$\lambda^{E}$の項$\mathtt{t'_{1}}$が取れる．ゆえに$\mathtt{u} = (\mathtt{\lambda x: Unit.}e(\mathtt{t_{2}}))e(\mathtt{t'_{1}}) = e(\mathtt{t'_{1};t_{2}})$となり従う．
        \end{itemize}
        \end{enumerate}
        \end{enumerate}
    \end{proof}
\end{frame}
\begin{frame}{\S11.4.型指定}
項の型を明示的に指定する機能を導入しよう．\begin{alertblock}{Def. 型指定}
型$\mathtt{T}$を指定した項$\mathtt{t}$を，$\mathtt{t\ as\ T}$と書く．評価規則を次のように定める:
\infax[E-Ascribe]{\mathtt{v_{1}\ as\ T\longrightarrow v_{1}}}
\infrule[E-Ascribe1]{\mathtt{t_{1}\longrightarrow t'_{1}}}{\mathtt{t_{1}\ as\ T\longrightarrow t'_{1}\ as\ T}}
型付け規則を次のように定める:
\infrule[T-Ascribe1]{\Gamma\vdash\mathtt{t_{1}:T}}{\Gamma\vdash\mathtt{t_{1}\ as\ T:T}}
\end{alertblock}
\end{frame}
\begin{frame}{演習 11.4.1.}
\begin{alertblock}{演習 11.4.1.[推奨]}
\begin{enumerate}
\item 型指定を派生形式として形式化せよ．「公式」の型付け規則および評価規則が，その形式化に何らかの適切な意味で対応することを証明せよ．
\item Def.で定めた評価規則の代わりに，以下の先行的な規則が与えられたとする:\infax[E-AscribeEager]{\mathtt{t_{1}\ as\ T\longrightarrow t_{1}}}．この場合にも，型指定を派生形式として扱うことはできるか．
\end{enumerate}
\end{alertblock}
\end{frame}
\begin{frame}{Ex11.4.1.の解答}
\begin{enumerate}
\item $\mathtt{t\ as\ T}$の派生形式は$\mathtt{(\lambda x:T.x)\ t}$とすればよい．また，拡張された構文の項を拡張前の項に写す関数$e$を次のように定める:
\begin{equation*}e(t) = \begin{cases}
\mathtt{(\lambda x:T. x)\ t_{1}}& \text{$\mathtt{t}$が$\mathtt{t_{1}:T}$の形のとき} \\
\mathtt{t} & \text{otherwise}
\end{cases}\end{equation*}．$e$は明らかに全単射である．「公式」の型付けおよび評価規則が派生形式と対応することを示すためには，次の補題を示せばよい．
\begin{alertblock}{Cor.}\begin{enumerate}
\item $\mathtt{t\longrightarrow t'}$のとき$\mathtt{e(t)\longrightarrow e(t')}$．また，$\mathtt{e(t)\longrightarrow u}$ならば型指定された項$\mathtt{t'}$が存在して$\mathtt{u = e(t')\land t\longrightarrow t'}$
\item (型付け)$\Gamma\vdash\mathtt{t:T}$，かつそのときに限り$\Gamma\vdash \mathtt{e(t):T}$
\end{enumerate}
\end{alertblock}
\end{enumerate}
\end{frame}
\begin{frame}{Ex11.4.1:補題の証明}
\begin{enumerate}
\item 前半部分は，$\mathtt{t}$を$\mathtt{t = t_{1}:T}$の形に限定し，$\mathtt{t_{1}}$が値か否かで分ければ示せる．後半部分についても$\mathtt{t}$が型指定された項$\mathtt{t_{1}\ as\ T}$の場合のみに限定し，$\mathtt{e(t) = (\lambda x:T. x)t_{1}}$，$\mathtt{u}$は$\mathtt{t_{1}}$が値のとき$\mathtt{t_{1}}$，そうでないとき$\mathtt{(\lambda x:T. x)t'_{1}}$(ただし$\mathtt{t_{1}\longrightarrow t'_{1}}$)に評価されることに注意すれば，評価された項に$e$の逆関数を適用して存在が示せる．
\item $\Gamma\vdash\mathtt{t\ as\ T}$の型導出は次のようになるので，$\Gamma\vdash\mathtt{t:T}$が成立:\begin{prooftree}\AxiomC{$\vdots$}\UnaryInfC{$\Gamma\vdash\mathtt{t:T}$}\UnaryInfC{$\Gamma\vdash\mathtt{t\ as\ T:T}$}\end{prooftree}
$\Gamma\vdash\mathtt{e(t\ as\ T):T}$に至る導出木は，$\Gamma\vdash\mathtt{t:T}$に至る部分木から下の導出木を作ることで示せる:\begin{prooftree}
\AxiomC{$\Gamma,\mathtt{x:T}\vdash\mathtt{x:T}$}
\UnaryInfC{$\Gamma\vdash\mathtt{\lambda x:T.x:T\to T}$}
\AxiomC{$\vdots$}
\UnaryInfC{$\Gamma\vdash\mathtt{t:T}$}
\BinaryInfC{$\Gamma\vdash \mathtt{e(t\ as\ T) = (\lambda x:T.x)\ t:T}$}
\end{prooftree}

逆向きの主張は，上の導出木の部分木で$\Gamma\vdash\mathtt{t:T}$が成立していることから，$\tiny\rm{T-ASCRIBE}$を用いて示せる．
\end{enumerate}
\end{frame}
\begin{frame}{Ex11.4.1(2)}
派生形式として表わすことができる．型指定された項の評価を進めることなく消去するので，次のように定義すればよい:\begin{equation}
\mathtt{t\ as\ T\stackrel{def}{=}(\lambda x:Unit\to T.x\ Unit)(\lambda y:Unit.t_{1})}
\end{equation}
\end{frame}
\begin{frame}{\S11.5.let 束縛}
部分式に対して名付けるための機能である$\mathtt{let}$束縛子を導入する.
\begin{alertblock}{Def.let 束縛}
式$\mathtt{t_{1}}$を評価した値を変数$\mathtt{x}$に束縛した状態で項$\mathtt{t_{2}}$を評価する．これを，式$\mathtt{let\ x=t_{1}\ in\ t_{2}}$で表わす．評価規則を次のように定める:
\infax[E-LetV]{\mathtt{let\ x=v_{1}\ in\ t_{2}\longrightarrow \left[x\mapsto v_{1}\right]t_{2}}}
\infrule[E-Let]{\mathtt{t_{1}\longrightarrow t'_{1}}}{\mathtt{let\ x=t_{1}\ in\ t_{2}\longrightarrow let\ x=t'_{1}\ in\ t_{2}}}

つまり，この定義における$\mathtt{let}$束縛子は値呼びである．型付け規則を次のように定める:
\infrule[T-Let]{\Gamma\vdash\mathtt{t_{1}:T_{1}}\andalso \Gamma,\mathtt{x:T_{1}}\vdash \mathtt{t_{2}:T_{2}}}{\Gamma\vdash\mathtt{let\ x=t_{1}\ in\ t_{2}}}
つまり，束縛項の型を計算し，その型を持つ束縛で水増しされた文脈で本体の型を計算することで，$\mathtt{let}$式全体の型を計算している．
\end{alertblock}
\end{frame}
\begin{frame}{$\mathtt{let}$束縛に関する補足}
\begin{enumerate}
\item $\mathtt{let}$式は派生形式$\mathtt{let\ x=t_{1}\ in\ t_{2} \stackrel{def}{=}(\lambda x:T_{1}.t_{2})t_{1}}$として書けるが，束縛項の型は型検査器からしか分からない．
\begin{itemize}
\item 型指定などのように項を脱糖するのではない(構文的には束縛項の型が分からない!)
\item 派生形式は型付け導出\begin{prooftree}
\AxiomC{$\vdots$}
\UnaryInfC{$\Gamma\vdash\mathtt{t_{1}:T_{1}}$}
\AxiomC{$\vdots$}
\UnaryInfC{$\Gamma, \mathtt{x:T_{1}}\vdash\mathtt{t_{2}:T_{2}}$}
\BinaryInfC{$\Gamma\vdash\mathtt{let\ x=t_{1}\ in\ t_{2}}$}\end{prooftree}を\begin{prooftree}
\AxiomC{$\vdots$}
\UnaryInfC{$\Gamma,\mathtt{x:T_{1}\vdash t_{2}:T_{2}}$}
\UnaryInfC{$\Gamma\vdash\mathtt{\lambda x:T_{1}.t_{2}:T_{1}\to T_{2}}$}
\AxiomC{$\vdots$}
\UnaryInfC{$\Gamma\vdash\mathtt{t_{1}:T_{1}}$}
\BinaryInfC{$\Gamma\vdash\mathtt{(\lambda x:T_{1}.t_{2})t_{1}:T_{2}}$}
\end{prooftree}に写す変換とみなす必要がある．
\item また，今後$\mathtt{let}$多相を導入するさいに問題が生じる(後述).
\end{itemize}
\end{enumerate}
\end{frame}
\begin{frame}{\S11.7.直積}
型$T_{1},\ldots,T_{n}$に対して直積型$\{\mathtt{T_{i}}^{i\in1\ldots n}\}$と，直積型の項$t:\{\mathtt{T_{i}}^{1\in1\ldots n}\}$と各$j = 1,\ldots, n$に対する射影演算子$t.j:\{\mathtt{T_{i}}^{i\in1\ldots n}\}\to T_{j}$を導入する．
\begin{alertblock}{Def.$n$-tuple}
$n$項の直積の導入に伴う項，値および型の構文要素を次のように定める:\begin{enumerate}
\item (項)$\mathtt{t\Coloneq\ldots|\{t_{i}^{i\in 1\ldots n}\}|t.i}$
\item (値)$\mathtt{v\Coloneq\ldots|\{\mathtt{v_{i}^{i\in1\ldots n}}\}}$
\item (型)$\mathtt{T\Coloneq\ldots|\{\mathtt{T_{i}^{i\in1\ldots n}}\}}$
\end{enumerate}
評価規則を次のように定める:
\begin{columns}
\begin{column}{0.5\columnwidth}
\infax[E-ProjTuple]{\{\mathtt{v_{i}^{i\in1\ldots n}\}.j\longrightarrow v_{j}}}
\infrule[E-Proj]{\mathtt{t_{1}\longrightarrow t'_{1}}}{\mathtt{t_{1}.i\longrightarrow t'_{1}.i}}
\end{column}
\begin{column}{0.5\columnwidth}
\infrule[E-Tuple]{\mathtt{t_{j}\longrightarrow t'_{j}}}{\{\mathtt{v_{i}^{i\in1\ldots j-1}}, t_{j}, \mathtt{t_{k}^{k\in j+1\ldots n}}\}\\\longrightarrow \{\mathtt{v_{i}^{i\in1\ldots j- 1}},t'_{j},\mathtt{t_{k}^{k\in j + 1\ldots n}}\}}
\end{column}
\end{columns}
\end{alertblock}
\end{frame}
\begin{frame}{\S11.7.(つづき)}
\begin{alertblock}{Def.$n$-tuple(つづき)}
型付け規則は以下の 2 つ:
\infrule[T-Tuple]{\forall i. \Gamma\vdash\mathtt{t_{i}:T_{i}}}{\Gamma\vdash\{\mathtt{t_{i}^{i\in1\ldots n}\}:\{T_{i}^{i\in1\ldots n}\}}}
\infrule[T-Proj]{\Gamma\vdash\mathtt{t_{1}:\{T_{i}^{i\in1\ldots n}\}}}{\Gamma\vdash\mathtt{t_{1}.j:T_{j}}}
\end{alertblock}
\dnote{規則$\rn{E-ProjTuple}$は，次のように書き直せる:
\infrule[E-ProjTuple]{1\leq j\leq n}{\mathtt{\{v_{i}^{i\in 1\ldots j - 1}, v_{j},v_{k}^{k\in j + 1\ldots n}\}.j\longrightarrow v_{j}}}}
\end{frame}
\begin{frame}{\S11.6.二つ組}
型$\mathtt{T_{1}, T_{2}}$に対する直積型$\mathtt{T_{1}\times T_{2}}$と，直積型の項$\mathtt{t = \left\{t_{1},t_{2}\right\}:T_{1}\times T_{2}}$に対する射影演算子$\mathtt{t.1:T_{1}\times T_{2}\to T_{1}},\mathtt{t.2:T_{1}\times T_{2}\to T_{2}}$を導入する．
\begin{alertblock}{Def.2-tuple}
2 つ組の導入に伴う項，値および型の構文要素を次のように定める:\begin{enumerate}
\item $\mathtt{t\Coloneq\ldots|\left\{t, t\right\}|t.1|t.2}$
\item $\mathtt{v\Coloneq\ldots|\left\{v,v\right\}}$
\item $\mathtt{T\Coloneq\ldots|T\times T}$
\end{enumerate}
評価規則を次のように定める．組は第一成分から評価を進める．
\infax[E-PairBeta1]{\mathtt{\left\{v_{1},v_{2}\right\}.1\longrightarrow v_{1}}}
\infax[E-PairBeta2]{\mathtt{\left\{v_{1}, v_{2}\right\}.2\longrightarrow v_{2}}}
\end{alertblock}\end{frame}
\begin{frame}{\S11.6}
\begin{alertblock}{Def.2-tuple(続き)}
\begin{columns}
\begin{column}{0.5\columnwidth}
\infrule[E-Proj1]{\mathtt{t_{1}\longrightarrow t'_{1}}}{\mathtt{t_{1}.1\longrightarrow t'_{1}.1}}
\infrule[E-Proj2]{\mathtt{t_{1}\longrightarrow t'_{1}}}{\mathtt{t_{1}.2\longrightarrow t'_{1}.2}}
\infrule[E-Pair1]{\mathtt{t_{1}\longrightarrow t'_{1}}}{\mathtt{\left\{t_{1},t_{2}\right\}\longrightarrow \left\{t'_{1},t_{2}\right\}}}
\infrule[E-Pair2]{\mathtt{t_{2}\longrightarrow t'_{2}}}{\mathtt{\left\{v_{1},t_{2}\right\}\longrightarrow \left\{v_{1},t'_{2}\right\}}}
\end{column}
\begin{column}{0.5\columnwidth}
型付け規則
\infrule[T-Pair]{\Gamma\vdash\mathtt{t_{1}:T_{1}}\andalso \Gamma\vdash\mathtt{t_{2}:T_{2}}}{\Gamma\vdash\mathtt{\left\{t_{1},t_{2}\right\}:T_{1}\times T_{2}}}
\infrule[T-Proj1]{\Gamma\vdash\mathtt{t_{1}:T_{11}\times T_{12}}}{\Gamma\vdash\mathtt{t_{1}.1:T_{11}}}
\infrule[T-Proj2]{\Gamma\vdash\mathtt{t_{1}:T_{11}\times T_{12}}}{\Gamma\vdash\mathtt{t_{1}.2:T_{12}}}
\end{column}
\end{columns}
\end{alertblock}
\end{frame}
\begin{frame}{\S11.6.コメント}
評価規則により，二つ組は第一成分が値に評価されたのちに第二成分が評価される．たとえば，$\mathtt{t = \left\{pred\ 4,if\ true\ then\ false\ then\ false\right\}.1}$の簡約列は次のように定まる:
\begin{align*}
\mathtt{t}&\longrightarrow \mathtt{\left\{3, if\ true\ then\ true\ else\ false\right\}}.1\\
  &\longrightarrow \mathtt{\left\{3, true\right\}.1}\longrightarrow 3
\end{align*}

値の構文を追加することで，関数の引数として渡された 2 つ組は本体の評価前に完全に評価される．
\end{frame}
\begin{frame}{\S11.8.組}
$n$-タプルに対し，各フィールド$\mathtt{t_{i}}$に集合$\mathscr{L}$から選んだラベル$\mathtt{l_{j}}$を注記することで，ラベル付きレコードに一般化する．次のように定義する:
\begin{alertblock}{Def.レコード}
新しい構文形式:\begin{enumerate}
\item $\mathtt{t\Coloneq\ldots\{\l_{i}=t_{i}^{i\in1\ldots n}\}|t.l}$
\item $\mathtt{v\Coloneq\ldots|\{\l_{i}=v_{i}^{i\in1\ldots n}\}}$
\item $\mathtt{T\Coloneq\ldots|\{t_{i}:T_{i}^{i\in1\ldots n}\}}$
\end{enumerate}
\end{alertblock}
\end{frame}
\begin{frame}{\S11.8.(つづき)}
\begin{alertblock}{Def.レコード(つづき)}
\begin{columns}
\begin{column}{0.5\columnwidth}
評価規則は以下の通り．
\infax[E-ProjRcd]{\mathtt{\{l_{i}=v_{i}^{i\in1\ldots n}\}.l_{j}\longrightarrow v_{j}}}
\infrule[E-Proj]{\mathtt{t_{1}\longrightarrow t'_{1}}}{\mathtt{t_{1}.l\longrightarrow t'_{1}.l}}
\infrule[E-Rcd]{\mathtt{t_{j}\longrightarrow t'_{j}}}{\{\mathtt{l_{i}=v_{i}^{i\in1\ldots j- 1}, l_{j} = t_{j},l_{k}=t_{k}^{k\in j+1\ldots n}}\}\\\longrightarrow \{\mathtt{l_{i}=v_{i}^{i\in1\ldots j - 1}, l_{j} = t'_{j},l_{k}=t_{k}^{k\in j + 1\ldots n}}\}}

\end{column}
\begin{column}{0.5\columnwidth}
型付け規則は次の通り.
\infrule[T-Rcd]{\forall i, \Gamma\vdash\mathtt{t_{i}:T_{i}}}{\Gamma\vdash\{\mathtt{l_{i}=t_{i}^{i\in1\ldots n}}\}\{\mathtt{T_{i}^{i\in1\ldots n}}\}}
\infrule[T-Proj]{\Gamma\vdash t_{1}:\{\mathtt{t_{i}:T_{i}^{i\in1\ldots n}}\}}{\Gamma\vdash\mathtt{t_{1}.l_{j}:T_{j}}}
\end{column}
\end{columns}
\end{alertblock}
\dnote{$\rn{E-ProjRcd}$は次のように書き直せる:\infrule[E-ProjRcd]{1\leq j \leq n \andalso \mathtt{l_{j}}\in\mathscr{L}}{\{\mathtt{l_{i}= v_{i}^{i\in1\ldots n}\}.l_{j}\longrightarrow v_{j}}}}
\end{frame}
\begin{frame}{\S11.8.レコードパターン}

\end{frame}
\begin{frame}{\S11.9.和}
型$\mathtt{T_{1},T_{2}}$に対する(二項の)和型$\mathtt{T_{1}+T_{2}}$と，項$\mathtt{t_{1}:T_{1}}$($\mathtt{t_{2}:T_{2}}$)から$\mathtt{T_{1}+T_{2}}$の項を構成するタグ$\mathtt{inl}(\mathtt{inr})$，そして和型上のパターンマッチのための構文を導入する．\footnote{$\mathtt{inl,inr}$は関数でない．}
\begin{alertblock}{Def.和型}
新しい構文形式\begin{enumerate}
\item (項)$\mathtt{t\Coloneq\ldots|inl\ t|inr\ t|case\ t\ of\ inl\ x\Rightarrow t|inr\ x\Rightarrow t}$
\item (値)$\mathtt{v\Coloneq\ldots|inl\ v|inr\ v}$
\item (型)$\mathtt{T\Coloneq\ldots|T+T}$
\end{enumerate}
評価規則を次のように定める:
\infax[E-CaseInl]{\mathtt{case(inl\ v_{0})\ of\ inl\ x_{1}\Rightarrow t_{1}}\\\mathtt{|inr\ x_{2}\Rightarrow t_{2}}\\\longrightarrow \mathtt{[x_{1}\mapsto v_{0}]t_{1}}}
\infax[E-CaseInr]{\mathtt{case(inr\ v_{0})\ of\ inl\ x_{1}\Rightarrow t_{1}}\\\mathtt{|inr\ x_{2}\Rightarrow t_{2}}\\\longrightarrow \mathtt{[x_{2}\mapsto v_{0}]t_{2}}}
\end{alertblock}
\end{frame}
\begin{frame}{\S11.9}
\begin{alertblock}{Def.和型}
\begin{columns}
\begin{column}{0.5\columnwidth}
\infrule[E-Case]{\mathtt{t_{0}\longrightarrow t'_{0}}}{\mathtt{case\ t_{0}\ of\ inl\ x_{1}\Rightarrow t_{1}|inr\ x_{2}\Rightarrow t_{2}}\\\longrightarrow \mathtt{case\ t'_{0}\ of\ inl\ x_{1}\Rightarrow t_{1}|inr\ x_{2}\Rightarrow t_{2}}}
\infrule[E-Inl]{\mathtt{t_{1}\longrightarrow t'_{1}}}{\mathtt{inl\ t_{1}\longrightarrow inl\ t'_{1}}}
\infrule[E-Inr]{\mathtt{t_{1}\longrightarrow t'_{1}}}{\mathtt{inr\ t_{1}\longrightarrow inr\ t'_{1}}}
\end{column}
\begin{column}{0.5\columnwidth}
\infrule[T-Inl]{\Gamma\vdash\mathtt{t_{1}:T_{1}}}{\Gamma\vdash\mathtt{inl\ t_{1}:T_{1}+T_{2}}}
\infrule[T-inr]{\Gamma\vdash\mathtt{t_{1}:T_{2}}}{\Gamma\vdash\mathtt{inr\ t_{1}:T_{1}+T_{2}}}
\end{column}
\end{columns}
\infrule[T-Case]{\Gamma\vdash\mathtt{t_{0}:T_{1}+T_{2}}\andalso \Gamma,\mathtt{x_{1}:T_{1}}\vdash\mathtt{t_{1}:T}\andalso \Gamma,\mathtt{x_{2}:T_{2}}\vdash\mathtt{t_{2}:T}}{\Gamma\vdash\mathtt{case\ t_{0}\ of\ inl\ x_{1}\Rightarrow t_{1}|inr\ x_{2}\Rightarrow t_{2}:T}}
\end{alertblock}
\end{frame}
\begin{frame}{\S11.9.和と型の一意性}
型付け規則$\rn{T-Inl}(\rn{T-Inr})$によれば，型導出の仮定に含まれない型には任意性がある．したがって，型の一意性(Thm.9.3.3)は成立しない．一意性を取り戻す方法としては，3 つ考えられる:\begin{enumerate}
\item 型検査アルゴリズムに変更を加え，不定となっている型を推論させる(\S22 で扱う．)
\item 型の言語を改良し，可能な全ての$\mathtt{T_{2}}$を統一的に表現できるようにする．部分型を用いる．
\item 型注釈を付ける．今回はこちらを用いる．
\end{enumerate}
評価および型付け規則は，全頁に示した規則に加え，型注釈つきの和型に対する規則を加えればよい．
\end{frame}
\begin{frame}{\S11.9.}
\begin{alertblock}{Def.和(一意型付け)}
\begin{columns}
\begin{column}{0.5\columnwidth}
新しい構文形式\begin{enumerate}
\item 項:$\mathtt{t\Coloneq\ldots|inl\ t\ as\ T|inr\ t\ as\ T}$
\item 値:$\mathtt{v\Coloneq\ldots|inl\ v\ as\ T|inr\ v\ as\ T}$
\end{enumerate}
新しい評価規則
\infax[E-CaseInl]{\mathtt{case\ (inl\ v_{0}\ as\ T_{0})\ of\ inl\ x_{1}\Rightarrow t_{1}}\\\mathtt{|inr\ x_{2}\Rightarrow t_{2}}\\\longrightarrow\mathtt{[x_{1}\mapsto v_{0}]t_{1}}}
\infax[E-CaseInr]{\mathtt{case\ (inr\ v_{0}\ as\ T_{0})\ of\ inl\ x_{1}\Rightarrow t_{1}}\\\mathtt{|inr\ x_{2}\Rightarrow t_{2}}\\\longrightarrow\mathtt{[x_{2}\mapsto v_{0}]t_{2}}}
\end{column}
\begin{column}{0.5\columnwidth}
\infrule[E-Inl]{\mathtt{t_{1}\longrightarrow t'_{1}}}{\mathtt{inl\ t_{1}\ as\ T_{2}\longrightarrow inl\ t'_{1}\ as\ T_{2}}}
\infrule[E-Inr]{\mathtt{t_{1}\longrightarrow t'_{1}}}{\mathtt{inr\ t_{1}\ as\ T_{2}\longrightarrow inr\ t'_{2}\ as\ T_{2}}}
型付け規則
\infrule[T-Inl]{\Gamma\vdash\mathtt{t_{1}:T_{1}}}{\Gamma\vdash\mathtt{inl\ t_{1}\ as\ T_{1}+T_{2}:T_{1}+T_{2}}}
\infrule[T-Inr]{\Gamma\vdash\mathtt{t_{1}:T_{2}}}{\Gamma\vdash\mathtt{inr\ t_{1}\ as\ T_{1}+T_{2}:T_{1}+T_{2}}}
\end{column}
\end{columns}
\end{alertblock}
\end{frame}
\end{document}
